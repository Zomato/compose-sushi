{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Build better with Sushi","text":"<p>Sushi is a sleek, modular Compose UI design system powering consistent user experiences across Zomato and its family of brands. Sushi brings you a fresh, reusable UI experience - designed to roll beautifully across Android. Support for iOS, Desktop, Web, and more coming soon.</p> <p>Sushi is ready for general use, but the API is considered unstable as we continue to iterate on it.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For introduction and basic setup, click here.</p>"},{"location":"#components","title":"Components","text":"SushiText SushiIcon SushiButton SushiImage SushiCheckBox SushiRadioButton SushiSwitch SushiTag SushiTextField SushiAnimation SushiLoader SushiCard SushiIndicators SushiDivider SushiShimmer SushiSnackbar SushiBottomSheet SushiDialog SushiDropDown SushiMedia SushiOTPInput SushiHorizontalPager SushiVerticalPager SushiRatingBar SushiTooltip SushiViewFlipper"},{"location":"#special-thanks","title":"Special Thanks","text":"<ul> <li>Thanks to Compose Material upon which this library is based.</li> <li>Thanks to Lumo UI for implementation references.</li> <li>Thanks to Compose Unstyled and Material for MkDocs for the documentation site.</li> </ul>"},{"location":"installation/","title":"Setup","text":"<p>The source code for Sushi, its samples, and this website is available on GitHub.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>Add Sushi Compose UI to your project by including the dependency in your build.gradle file: build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.eternal.kits:sushi-compose:0.0.1\")\n}\n</code></pre></p>"},{"location":"installation/#r8-proguard","title":"R8 / ProGuard","text":"<p>If you are using R8 the shrinking and obfuscation rules are included automatically. </p>"},{"location":"introduction/","title":"Sushi UI","text":"<p>Sushi UI is a comprehensive design system for Jetpack Compose that provides a rich set of customizable components for building beautiful, consistent, and accessible user interfaces.</p>"},{"location":"introduction/#overview","title":"Overview","text":"<p>Sushi UI offers a collection of ready-to-use components that follow a consistent design language while providing extensive customization options. The library is built on top of Jetpack Compose and is designed to make UI development faster, more consistent, and more enjoyable.</p>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#comprehensive-component-library","title":"Comprehensive Component Library","text":"<p>Sushi UI includes a wide range of components from basic atoms like buttons, text fields, and cards to complex components like bottom sheets, dialogs, and navigation components. Each component is carefully designed to provide a consistent look and feel while offering extensive customization options.</p>"},{"location":"introduction/#consistent-props-based-api","title":"Consistent Props-Based API","text":"<p>All components follow a consistent API pattern using Props objects that make customization intuitive and easy to understand. This approach ensures that components are used consistently throughout your application and reduces the learning curve for developers.</p>"},{"location":"introduction/#theming-system","title":"Theming System","text":"<p>Sushi UI provides a robust theming system that allows you to customize the look and feel of all components with minimal effort. The theming system includes:</p> <ul> <li>Color schemes with light and dark variants</li> <li>Typography scales</li> <li>Dimension systems</li> <li>Shape definitions</li> </ul>"},{"location":"introduction/#accessibility-built-in","title":"Accessibility Built-In","text":"<p>Accessibility features are built into every component, ensuring that your applications are usable by everyone, including people with disabilities. Components follow WCAG guidelines and support TalkBack on Android.</p>"},{"location":"introduction/#markdown-support","title":"Markdown Support","text":"<p>Many text components in Sushi UI support markdown formatting, allowing you to easily add rich text formatting to your UI.</p>"},{"location":"introduction/#getting-started","title":"Getting Started","text":"<p>The best way to get started with Sushi UI is to explore the component documentation and examples. Check out the Button component to see how Sushi UI components work.</p>"},{"location":"introduction/#component-categories","title":"Component Categories","text":"<p>Sushi UI components are organized into the following categories:</p>"},{"location":"introduction/#atoms-and-components","title":"Atoms and Components","text":"<p>Building blocks that form the foundation of the design system:</p> <ul> <li>SushiText: Text component with styling options, decorations, prefix/suffix icons, expandable support, etc.</li> <li>SushiIcon: Component that displays an icon from the Sushi design system.</li> <li>SushiButton: Button component that supports different visual styles, sizes, and content configurations.</li> <li>SushiImage: Component that displays images in the Sushi design system.</li> <li>SushiCheckBox:Checkbox component for the Sushi design system.</li> <li>SushiRadioButton: Radio button component for the Sushi design system.</li> <li>SushiSwitch: Toggle switch component for the Sushi design system.</li> <li>SushiTag: Tag component for the Sushi design system.</li> <li>SushiTextField: Text input field component for the Sushi design system.</li> <li>SushiAnimation: Component for displaying animations in the Sushi design system, supports Lottie animations and different playback behaviors.</li> <li>SushiLoader: Component that displays an animated loading indicator with two concentric rotating arcs.</li> <li>SushiCard: Card component for the Sushi design system.</li> <li>SushiIndicator: Component to display page indicators for carousel, pager components, etc.</li> <li>SushiDivider: Component that displays a divider with various customizable styles.</li> <li>SushiShimmer: Component that displays a shimmer loading effect over placeholder content.</li> <li>SushiSnackbar: Component that displays a snackbar message with an optional action.</li> <li>SushiBottomSheet: Customizable bottom sheet component for the Sushi design system.</li> <li>SushiDialog: Customizable alert dialog component for the Sushi design system.</li> <li>SushiDropDown: Dropdown menu component with support for checkbox and radio based selections.</li> <li>SushiMedia: Unified media component for the Sushi design system that can display different types of media.</li> <li>SushiOTPInput: Customizable OTP (One-Time Password) input field component.</li> <li>SushiHorizontalPager: Component that allow users to swipe between pages of content horizontally.</li> <li>SushiVerticalPager: Component that allow users to swipe between pages of content vertically.</li> <li>SushiRatingBar: Rating bar component for the Sushi design system.</li> <li>SushiTooltip: Customizable tooltip component for the Sushi design system.</li> <li>SushiViewFlipper: Component that automatically cycles through multiple content items with animated transitions.</li> </ul>"},{"location":"introduction/#design-principles","title":"Design Principles","text":"<p>Sushi UI is built with the following principles in mind:</p> <ol> <li>Consistency: All components follow the same design language and API patterns</li> <li>Customization: Every aspect of the components can be customized to fit your needs</li> <li>Accessibility: Components are designed to be usable by everyone</li> <li>Performance: Components are optimized for performance and minimal recompositions</li> <li>Developer Experience: APIs are intuitive and easy to use</li> </ol>"},{"location":"introduction/#contributing","title":"Contributing","text":"<p>Sushi UI is an open-source project, and contributions are welcome. Please check the GitHub repository for more information on how to contribute.</p>"},{"location":"shapes/","title":"Sushi Custom Shapes","text":"<p>Sushi Compose UI offers a variety of ready-made shapes for avatars, cards, buttons, and more, making your UI feel both playful and branded.</p>"},{"location":"shapes/#built-in-shapes","title":"Built-in Shapes","text":"<p>Common Sushi shapes include:</p> <ul> <li>Ticket Shape</li> <li>Squircle Shape.</li> </ul> <p>Example usage:</p> <pre><code>Box(\n    Modifier\n        .clip(SquircleShape(radius = SushiTheme.dimens.spacing.base))\n) {\n    // Content\n}\n</code></pre>"},{"location":"sushianimation/","title":"SushiAnimation","text":"<p>A composable component for displaying animations in the Sushi design system. Supports Lottie animations from various sources with customizable playback behavior.</p> <p>SushiAnimation provides a convenient way to integrate Lottie animations into your application, with support for animations from different sources:</p> <ul> <li>Assets directory</li> <li>File system</li> <li>JSON strings</li> <li>Android resources</li> <li>URLs</li> <li>Pre-loaded Lottie compositions</li> </ul>"},{"location":"sushianimation/#example","title":"Example","text":"<p>The <code>SushiAnimation</code> component is used to display Lottie animations with various configurations.</p> <pre><code>// Auto-play animation from asset file\nval autoPlayProps by rememberSushiAnimationProps(\n    source = LottieAssetSource(\"animation.json\"),\n    playback = SushiAnimationPlayback.AutoPlay(\n        isPlaying = true,\n        restartOnPlay = true,\n        reverseOnRepeat = false,\n        speed = 1f,\n        iterations = -1  // Infinite loop\n    )\n)\n\nSushiAnimation(\n    props = autoPlayProps,\n    modifier = Modifier\n        .width(200.dp)\n        .height(200.dp)\n)\n\n// Manual control of animation progress\nval composition = rememberLottieComposition(LottieCompositionSpec.Asset(\"animation.json\"))\nvar progress by remember { mutableStateOf(0f) }\n\nval manualControlProps by rememberSushiAnimationProps(\n    source = LottieCompositionSource(composition.value),\n    playback = SushiAnimationPlayback.Progress { progress }\n)\n\nSushiAnimation(props = manualControlProps)\n\n// Update progress with a slider\nSlider(\n    value = progress,\n    onValueChange = { progress = it },\n    valueRange = 0f..1f\n)\n</code></pre>"},{"location":"sushianimation/#component-api","title":"Component API","text":""},{"location":"sushianimation/#sushianimation_1","title":"SushiAnimation","text":"Parameter Description <code>source</code> The animation source to be displayed <code>playback</code> The playback configuration controlling how the animation plays <code>width</code> Optional explicit width for the animation <code>height</code> Optional explicit height for the animation <code>aspectRatio</code> Optional aspect ratio to maintain (width:height) <code>bgColor</code> Background color for the animation container"},{"location":"sushianimation/#animation-sources","title":"Animation Sources","text":"<p>The component supports various sources for Lottie animations:</p> Source Type Description <code>LottieAssetSource</code> Animation from the app's assets directory <code>LottieFileSource</code> Animation from a file in the file system <code>LottieJsonSource</code> Animation from a JSON string <code>LottieResourceIdSource</code> Animation from an Android resource <code>LottieUrlSource</code> Animation loaded from a URL <code>LottieCompositionSource</code> Pre-loaded Lottie composition"},{"location":"sushianimation/#animation-playback","title":"Animation Playback","text":"<p>Controls how the animation plays:</p> Playback Type Description <code>AutoPlay</code> Automatically plays the animation with options for looping, speed, etc. <code>Progress</code> Manually control animation progress with a value provider function"},{"location":"sushibottomsheet/","title":"SushiBottomSheet","text":"<p>A customizable bottom sheet component for the Sushi design system.</p> <p>SushiBottomSheet provides a modal bottom sheet that slides up from the bottom of the screen to display additional content. The component is built on top of Material 3's ModalBottomSheet with Sushi-specific styling and integration with the Sushi design system.</p>"},{"location":"sushibottomsheet/#example","title":"Example","text":"<p>The <code>SushiBottomSheet</code> component is used to display content in a modal sheet that slides up from the bottom of the screen:</p> <pre><code>// First, create state variables to control the bottom sheet visibility\nvar showBottomSheet by remember { mutableStateOf(false) }\nval sheetState = rememberModalBottomSheetState()\nval scope = rememberCoroutineScope()\n\n// Button to show the bottom sheet\nSushiButton(\n    props = SushiButtonProps(text = \"Show Bottom Sheet\"),\n    onClick = { showBottomSheet = true },\n    modifier = Modifier.fillMaxWidth()\n)\n\n// Display the bottom sheet when triggered\nif (showBottomSheet) {\n    SushiBottomSheet(\n        props = SushiBottomSheetProps(),  // Using default props\n        onDismissRequest = { showBottomSheet = false },\n        sheetState = sheetState\n    ) {\n        // Bottom sheet content\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(24.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            SushiText(\n                props = SushiTextProps(\n                    text = \"Bottom Sheet Title\",\n                    type = SushiTextType.Bold700\n                )\n            )\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            SushiText(\n                props = SushiTextProps(\n                    text = \"This is the content of the bottom sheet.\",\n                    type = SushiTextType.Regular400\n                )\n            )\n\n            Spacer(modifier = Modifier.height(24.dp))\n\n            SushiButton(\n                props = SushiButtonProps(text = \"Close\"),\n                onClick = {\n                    scope.launch {\n                        sheetState.hide()\n                        showBottomSheet = false\n                    }\n                },\n                modifier = Modifier.fillMaxWidth()\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"sushibottomsheet/#customization-examples","title":"Customization Examples","text":"<pre><code>// Custom colored bottom sheet\nSushiBottomSheet(\n    props = SushiBottomSheetProps(\n        containerColor = SushiTheme.colors.blue.v050,  // Light blue background\n        contentColor = SushiTheme.colors.blue.v900     // Dark blue text\n    ),\n    onDismissRequest = { /* handler */ }\n) {\n    // Content\n}\n\n// Custom shape bottom sheet\nSushiBottomSheet(\n    props = SushiBottomSheetProps(\n        shape = RoundedCornerShape(\n            topStart = 48.dp,\n            topEnd = 48.dp\n        )\n    ),\n    onDismissRequest = { /* handler */ }\n) {\n    // Content\n}\n\n// Non-dismissible bottom sheet\nSushiBottomSheet(\n    props = SushiBottomSheetProps(\n        properties = ModalBottomSheetProperties(\n            shouldDismissOnBackPress = false\n        )\n    ),\n    onDismissRequest = { /* handler */ },\n    sheetState = rememberModalBottomSheetState(confirmValueChange = { false })\n) {\n    // Content with explicit dismiss button\n}\n</code></pre>"},{"location":"sushibottomsheet/#component-api","title":"Component API","text":""},{"location":"sushibottomsheet/#sushibottomsheetprops","title":"SushiBottomSheetProps","text":"Parameter Description <code>shape</code> The shape of the bottom sheet, typically defining rounded corners at the top <code>containerColor</code> The background color of the bottom sheet <code>contentColor</code> The color of the text and other content in the bottom sheet <code>tonalElevation</code> The elevation of the bottom sheet that affects its shadow and surface tint <code>properties</code> Additional properties controlling the bottom sheet behavior, such as scrim opacity and whether it's dismissible"},{"location":"sushibutton/","title":"SushiButton","text":"<p>A customizable button component that supports different visual styles, sizes, and content configurations.</p> <p>SushiButton provides a standardized button implementation with support for:</p> <ul> <li>Different visual styles (Text, Solid, Outline)</li> <li>Various sizes (Small, Medium, Large)</li> <li>Prefix and suffix icons</li> <li>Custom content through the content parameter</li> <li>Accessibility through semantic properties</li> </ul>"},{"location":"sushibutton/#example","title":"Example","text":"<p>The <code>SushiButton</code> component is used to create buttons with various styles and configurations.</p> <pre><code>SushiButton(\n    props = SushiButtonProps(\n        text = \"Solid Button\",\n        type = SushiButtonType.Solid,\n        prefixIcon = SushiIconProps(code = SushiIconCodes.IconStarFill)\n    ),\n    onClick = { /* Handle click */ },\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"sushibutton/#component-api","title":"Component API","text":""},{"location":"sushibutton/#sushibutton_1","title":"SushiButton","text":"Parameter Description <code>text</code> Primary text to display in the button <code>subText</code> Optional secondary text below the primary text <code>type</code> Button style type (Text, Solid, or Outline) <code>size</code> Button size variant (Small, Medium, or Large) <code>fontColor</code> Color for the button text <code>fontType</code> Typography style for the button text <code>color</code> Background color of the button <code>borderColor</code> Color of the button border (for Outline type) <code>suffixIcon</code> Optional icon to display after the button text <code>prefixIcon</code> Optional icon to display before the button text <code>enabled</code> Whether the button is enabled and can be interacted with <code>horizontalArrangement</code> How to arrange content horizontally in the button <code>verticalAlignment</code> How to align content vertically in the button <code>textAlignment</code> Horizontal alignment of text within the button <code>markdown</code> Whether to interpret text as markdown <code>shape</code> The shape of the button <code>iconSpacing</code> Spacing between icons and text"},{"location":"sushicard/","title":"SushiCard","text":"<p>A customizable card component for the Sushi design system.</p> <p>SushiCard provides a surface for displaying related content in a contained unit. It supports:</p> <ul> <li>Custom shapes including rounded corners and ticket shapes</li> <li>Solid and dashed borders</li> <li>Elevation control</li> <li>Custom background colors</li> <li>Content composition through ColumnScope</li> </ul>"},{"location":"sushicard/#example","title":"Example","text":"<p>The <code>SushiCard</code> component is used to create cards with various styles and configurations.</p> <pre><code>// Basic card with rounded corners\nSushiCard(\n    modifier = Modifier\n        .fillMaxWidth()\n        .padding(16.dp)\n) {\n    Column(\n        modifier = Modifier.padding(16.dp)\n    ) {\n        SushiText(\n            props = SushiTextProps(\n                text = \"Card Title\",\n                type = SushiTextType.SemiBold600\n            )\n        )\n\n        SushiText(\n            props = SushiTextProps(\n                text = \"Card content goes here with any composable content\",\n                type = SushiTextType.Regular400\n            ),\n            modifier = Modifier.padding(top = 8.dp)\n        )\n    }\n}\n\n// Card with custom background color and elevation\nSushiCard(\n    containerColor = SushiTheme.colors.blue.v100,\n    elevation = 8.dp,\n    modifier = Modifier\n        .fillMaxWidth()\n        .padding(16.dp)\n) {\n    // Card content here\n}\n\n// Card with solid border\nSushiCard(\n    border = BorderStroke(1.dp, SushiTheme.colors.grey.v300.value),\n    shape = RoundedCornerShape(12.dp),\n    modifier = Modifier\n        .fillMaxWidth()\n        .padding(16.dp)\n) {\n    // Card content here\n}\n\n// Card with dashed border and ticket shape\nSushiCard(\n    shape = TicketShape(16.dp.toPx(), 0.7f),\n    borderConfig = DashedBorderConfig(\n        color = SushiTheme.colors.red.v500.value,\n        width = 2.dp,\n        dashWidth = 5.dp,\n        dashGap = 6.dp,\n        shape = TicketShape(16.dp.toPx(), 0.7f)\n    ),\n    modifier = Modifier\n        .fillMaxWidth()\n        .padding(16.dp)\n) {\n    // Card content here\n}\n</code></pre>"},{"location":"sushicard/#component-api","title":"Component API","text":""},{"location":"sushicard/#sushicard_1","title":"SushiCard","text":"Parameter Description <code>modifier</code> The modifier to be applied to the card <code>borderConfig</code> Optional configuration for custom borders (e.g., dashed borders) <code>shape</code> The shape of the card (defaults to rounded corners) <code>containerColor</code> The background color of the card <code>border</code> Optional border stroke for the card (for solid borders) <code>elevation</code> The elevation of the card which determines its shadow <code>content</code> The composable content to be displayed inside the card"},{"location":"sushicard/#dashedborderconfig","title":"DashedBorderConfig","text":"Parameter Description <code>color</code> The color of the border <code>width</code> The thickness of the border line <code>dashWidth</code> The width of each dash in the pattern <code>dashGap</code> The gap between each dash in the pattern <code>shape</code> The shape to apply the border to (e.g., rectangle, rounded corner)"},{"location":"sushicheckbox/","title":"SushiCheckBox","text":"<p>A customizable checkbox component for the Sushi design system.</p> <p>SushiCheckBox provides a standard checkbox implementation with support for:</p> <ul> <li>Different sizes (Mini, Default)</li> <li>Primary and secondary text labels</li> <li>Custom positioning (checkbox at start or end)</li> <li>Vertical alignment control</li> <li>Custom content through the infoContent parameter</li> <li>Consistent styling with the design system</li> </ul>"},{"location":"sushicheckbox/#example","title":"Example","text":"<p>The <code>SushiCheckBox</code> component is used to create checkboxes with different configurations.</p> <pre><code>var checked by remember { mutableStateOf(false) }\n\nSushiCheckBox(\n    props = SushiCheckBoxProps(\n        checked = checked,\n        text = SushiTextProps(text = \"I accept the terms and conditions\"),\n        subText = SushiTextProps(\n            text = \"By checking this box, you agree to our Terms of Service\",\n            type = SushiTextType.Regular300,\n            color = SushiTheme.colors.text.secondary\n        ),\n        color = SushiTheme.colors.green.v600\n    ),\n    onCheckedChange = { checked = it },\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"sushicheckbox/#component-api","title":"Component API","text":""},{"location":"sushicheckbox/#sushicheckbox_1","title":"SushiCheckBox","text":"Parameter Description <code>id</code> Optional identifier for the checkbox <code>checked</code> Whether the checkbox is checked (true) or unchecked (false) <code>text</code> Primary text properties to display alongside the checkbox <code>subText</code> Secondary text properties to display below the primary text <code>enabled</code> Whether the checkbox is interactive (true) or disabled (false) <code>color</code> The color for the checkbox when checked <code>size</code> The size variant of the checkbox (Mini or Default) <code>boxPadding</code> The padding around the checkbox component <code>verticalAlignment</code> The vertical alignment of the checkbox relative to its text <code>direction</code> The position of the checkbox relative to its text (Start or End)"},{"location":"sushidialog/","title":"SushiAlertDialog","text":"<p>A customizable alert dialog component for the Sushi design system.</p> <p>SushiAlertDialog provides a modal dialog for displaying important information or requesting user decisions. It supports an optional header image, title, subtitle, custom content, and up to three action buttons. The dialog can be configured with different button layouts (vertical or horizontal) and dismissal behaviors.</p>"},{"location":"sushidialog/#example","title":"Example","text":"<p>The <code>SushiAlertDialog</code> component is used to create modal dialogs for important interactions:</p> <pre><code>// First, create state to control the dialog's visibility\nvar showDialog by remember { mutableStateOf(false) }\n\n// Button to show the dialog\nSushiButton(\n    props = SushiButtonProps(text = \"Show Dialog\"),\n    onClick = { showDialog = true },\n    modifier = Modifier.fillMaxWidth()\n)\n\n// Display the dialog when needed\nif (showDialog) {\n    SushiAlertDialog(\n        props = SushiAlertDialogProps(\n            title = SushiTextProps(\n                text = \"Confirm Action\",\n                type = SushiTextType.Bold600,\n                textAlign = TextAlign.Center\n            ),\n            subtitle = SushiTextProps(\n                text = \"Are you sure you want to proceed with this action?\",\n                type = SushiTextType.Regular400,\n                textAlign = TextAlign.Center\n            ),\n            positiveButton = SushiButtonProps(\n                text = \"Confirm\",\n                type = SushiButtonType.Text,\n                horizontalArrangement = Arrangement.Center\n            ),\n            negativeButton = SushiButtonProps(\n                text = \"Cancel\",\n                type = SushiButtonType.Text,\n                horizontalArrangement = Arrangement.Center\n            )\n        ),\n        onDismissRequest = { showDialog = false },\n        onPositiveButtonClick = { \n            // Handle positive action\n            showDialog = false \n        },\n        onNegativeButtonClick = { showDialog = false }\n    ) {\n        // Optional additional content\n        Spacer(modifier = Modifier.height(8.dp))\n    }\n}\n</code></pre>"},{"location":"sushidialog/#customization-examples","title":"Customization Examples","text":"<pre><code>// Dialog with image\nSushiAlertDialog(\n    props = SushiAlertDialogProps(\n        image = SushiImageProps(\n            painter = painterResource(R.drawable.success_icon),\n            contentScale = ContentScale.Fit,\n            bgColor = SushiTheme.colors.green.v100,\n            width = 80.dp,\n            height = 80.dp,\n            shape = CircleShape\n        ),\n        title = SushiTextProps(text = \"Success!\"),\n        subtitle = SushiTextProps(text = \"Your order has been placed successfully.\"),\n        positiveButton = SushiButtonProps(text = \"OK\")\n    ),\n    onDismissRequest = { /* handler */ },\n    onPositiveButtonClick = { /* handler */ }\n) {\n    // Optional content\n}\n\n// Dialog with vertical buttons\nSushiAlertDialog(\n    props = SushiAlertDialogProps(\n        title = SushiTextProps(text = \"Rate Your Experience\"),\n        subtitle = SushiTextProps(text = \"How would you rate your food delivery experience?\"),\n        alignment = SushiAlertDialogProps.ButtonAlignment.Vertical,\n        positiveButton = SushiButtonProps(text = \"Excellent\"),\n        negativeButton = SushiButtonProps(text = \"Average\"),\n        neutralButton = SushiButtonProps(text = \"Poor\")\n    ),\n    onDismissRequest = { /* handler */ },\n    onPositiveButtonClick = { /* handler */ },\n    onNegativeButtonClick = { /* handler */ },\n    onNeutralButtonClick = { /* handler */ }\n) {\n    // Optional content\n}\n\n// Non-dismissible dialog\nSushiAlertDialog(\n    props = SushiAlertDialogProps(\n        title = SushiTextProps(text = \"Important Notice\"),\n        subtitle = SushiTextProps(text = \"This requires your confirmation.\"),\n        positiveButton = SushiButtonProps(text = \"I Understand\"),\n        dismissOnBackPress = false,\n        dismissOnClickOutside = false\n    ),\n    onDismissRequest = { /* Cannot dismiss except by button */ },\n    onPositiveButtonClick = { /* handler */ }\n) {\n    // Content\n}\n</code></pre>"},{"location":"sushidialog/#component-api","title":"Component API","text":""},{"location":"sushidialog/#sushialertdialogprops","title":"SushiAlertDialogProps","text":"Parameter Description <code>id</code> Optional identifier for the dialog <code>image</code> Optional image to display at the top of the dialog <code>title</code> Optional title text displayed at the top of the dialog <code>subtitle</code> Optional subtitle text displayed below the title <code>positiveButton</code> Optional properties for the primary action button <code>negativeButton</code> Optional properties for the secondary action button <code>neutralButton</code> Optional properties for the tertiary action button <code>alignment</code> How the buttons should be arranged (vertically or horizontally) <code>dismissOnBackPress</code> Whether the dialog should dismiss when the back button is pressed <code>dismissOnClickOutside</code> Whether the dialog should dismiss when clicked outside its bounds"},{"location":"sushidialog/#buttonalignment","title":"ButtonAlignment","text":"Value Description <code>Vertical</code> Buttons are arranged vertically (stacked), each taking the full width of the dialog <code>Horizontal</code> Buttons are arranged horizontally (side by side) at the bottom of the dialog"},{"location":"sushidivider/","title":"SushiDivider","text":"<p>A composable that displays a divider with various customizable styles.</p> <p>SushiDivider provides visual separation between content sections using different line styles such as solid, dotted, dashed, and decorative patterns like zigzags. It supports both horizontal and vertical orientations as well as customizable colors and thicknesses.</p>"},{"location":"sushidivider/#example","title":"Example","text":"<p>The <code>SushiDivider</code> component is used to create visual separation between content elements.</p> <pre><code>// Basic straight divider\nSushiDivider(\n    props = SushiDividerProps(\n        type = SushiDividerType.Straight,\n        color = SushiColorData(ColorName.Red, ColorVariation.Variation500)\n    ),\n    Modifier.fillMaxWidth().padding(vertical = 16.dp)\n)\n\n// Dotted divider\nSushiDivider(\n    props = SushiDividerProps(\n        type = SushiDividerType.Dotted,\n        color = SushiColorData(ColorName.Blue, ColorVariation.Variation500)\n    ),\n    Modifier.fillMaxWidth().padding(vertical = 16.dp)\n)\n\n// ZigZag pattern divider\nSushiDivider(\n    props = SushiDividerProps(\n        type = SushiDividerType.ZigZag(\n            direction = SushiDividerType.ZigZag.Direction.Top,\n            radius = 2.dp,\n            width = 24.dp,\n            height = 12.dp\n        ),\n        color = SushiColorData(ColorName.Green, ColorVariation.Variation500),\n    ),\n    Modifier.fillMaxWidth().padding(vertical = 16.dp)\n)\n</code></pre>"},{"location":"sushidivider/#component-api","title":"Component API","text":""},{"location":"sushidivider/#sushidividerprops","title":"SushiDividerProps","text":"Parameter Description <code>type</code> The visual style of the divider (default is SushiDividerType.Straight) <code>color</code> The color of the divider (default is determined by theme) <code>height</code> The thickness of the divider (default varies by type)"},{"location":"sushidivider/#sushidividertype","title":"SushiDividerType","text":"<p>The <code>SushiDividerType</code> defines different visual styles for dividers:</p> Type Description <code>Straight</code> A standard solid straight line divider <code>Dotted</code> A dotted line divider with small, closely spaced dots <code>Dashed</code> A dashed line divider with small dashes and gaps <code>StraightThick</code> A solid straight line divider with a thicker stroke width <code>DottedSpaced</code> A dotted line divider with larger spacing between dots <code>Vertical</code> A vertical solid straight line divider <code>VerticalDotted</code> A vertical dotted line divider with small, closely spaced dots <code>ZigZag</code> A decorative zigzag pattern divider with configurable direction, radius, width, and height <code>Pink</code> A special pink-colored divider (project-specific) <code>Menu</code> A menu-style divider with a triangular notch (project-specific)"},{"location":"sushidropdown/","title":"SushiDropDown","text":"<p>A customizable dropdown menu component for the Sushi design system.</p> <p>SushiDropDown provides a popup menu that can contain various types of items including text items, checkboxes, and radio buttons. The dropdown can be anchored to any component and supports custom content or predefined item types.</p>"},{"location":"sushidropdown/#example","title":"Example","text":"<p>The <code>SushiDropDown</code> component is used to create dropdown menus with various types of items:</p> <pre><code>// First, create state variables to control the dropdown visibility\nvar isExpanded by remember { mutableStateOf(false) }\n\n// Create a trigger element (like a button)\nSushiButton(\n    props = SushiButtonProps(\n        text = \"Show Dropdown\",\n        prefixIcon = SushiIconProps(code = SushiIconCodes.IconChevronDown)\n    ),\n    onClick = { isExpanded = true }\n)\n\n// Create the dropdown items\nval items = persistentListOf(\n    // Text items\n    DropDownItem.TextItem(SushiTextProps(text = \"Option 1\")),\n    DropDownItem.TextItem(SushiTextProps(text = \"Option 2\")),\n\n    // Checkbox items\n    DropDownItem.CheckBoxItem(SushiCheckBoxProps(\n        text = SushiTextProps(text = \"Checkbox Option\"),\n        checked = false\n    )),\n\n    // Radio button items\n    DropDownItem.RadioButtonItem(SushiRadioButtonProps(\n        text = SushiTextProps(text = \"Radio Option\"),\n        selected = true\n    ))\n)\n\n// Show the dropdown when expanded\nif (isExpanded) {\n    SushiDropDown(\n        props = SushiDropDownProps(\n            expanded = true,\n            items = items\n        ),\n        onDismissRequest = { isExpanded = false },\n        onEvent = { index, event -&gt;\n            when (event) {\n                is DropDownEvent.OnTextItemClicked -&gt; {\n                    // Handle text item click\n                    isExpanded = false\n                }\n                is DropDownEvent.OnCheckChanged -&gt; {\n                    // Handle checkbox state change\n                    // Update your items list with the new state\n                }\n                is DropDownEvent.OnRadioButtonCheckChanged -&gt; {\n                    // Handle radio button selection\n                    // Update your items list with the new selection\n                }\n            }\n        }\n    )\n}\n</code></pre>"},{"location":"sushidropdown/#customization-examples","title":"Customization Examples","text":"<pre><code>// Custom positioning with offset\nSushiDropDown(\n    props = SushiDropDownProps(\n        expanded = isExpanded,\n        offset = DpOffset(20.dp, 10.dp),\n        items = items\n    ),\n    onDismissRequest = { /* handler */ }\n)\n\n// Custom shape\nSushiDropDown(\n    props = SushiDropDownProps(\n        expanded = isExpanded,\n        shape = RoundedCornerShape(16.dp),\n        items = items\n    ),\n    onDismissRequest = { /* handler */ }\n)\n\n// Custom color and border\nSushiDropDown(\n    props = SushiDropDownProps(\n        expanded = isExpanded,\n        containerColor = SushiTheme.colors.blue.v700.value,\n        border = BorderStroke(2.dp, SushiTheme.colors.base.theme.v500.value),\n        items = items\n    ),\n    onDismissRequest = { /* handler */ }\n)\n\n// Custom content\nSushiDropDown(\n    props = SushiDropDownProps(expanded = isExpanded),\n    onDismissRequest = { /* handler */ },\n    content = {\n        Column(modifier = Modifier.padding(16.dp)) {\n            SushiText(props = SushiTextProps(text = \"Custom Header\"))\n\n            // Custom items or content\n            Row(verticalAlignment = Alignment.CenterVertically) {\n                SushiIcon(props = SushiIconProps(code = SushiIconCodes.IconCheck))\n                SushiText(props = SushiTextProps(text = \"Custom Item\"))\n            }\n\n            // You can use SushiDropDownItem for consistent styling\n            SushiDropDownItem(\n                item = DropDownItem.TextItem(SushiTextProps(text = \"Item\")),\n                onEvent = { /* handler */ }\n            )\n        }\n    }\n)\n</code></pre>"},{"location":"sushidropdown/#component-api","title":"Component API","text":""},{"location":"sushidropdown/#sushidropdownprops","title":"SushiDropDownProps","text":"Parameter Description <code>expanded</code> Whether the dropdown menu is currently shown <code>offset</code> Position offset from the anchor position <code>properties</code> Additional popup properties (e.g., focusability, dismiss behavior) <code>shape</code> The shape of the dropdown menu container <code>containerColor</code> The background color of the dropdown menu <code>tonalElevation</code> When using surface color, this affects the overlay color intensity <code>shadowElevation</code> The elevation that determines the size of the shadow <code>border</code> Optional border to draw around the dropdown <code>items</code> List of items to display in the dropdown menu"},{"location":"sushidropdown/#dropdownitem-types","title":"DropDownItem Types","text":"<p>The <code>DropDownItem</code> sealed interface supports three item types:</p> Type Description <code>TextItem</code> A simple text item in the dropdown menu <code>CheckBoxItem</code> A checkbox item in the dropdown menu <code>RadioButtonItem</code> A radio button item in the dropdown menu"},{"location":"sushidropdown/#dropdownevent-types","title":"DropDownEvent Types","text":"<p>The <code>DropDownEvent</code> sealed interface provides type-safe event handling:</p> Event Description <code>OnCheckChanged</code> Event fired when a checkbox item's checked state changes <code>OnRadioButtonCheckChanged</code> Event fired when a radio button item's selected state changes <code>OnTextItemClicked</code> Event fired when a text item is clicked"},{"location":"sushihorizontalpager/","title":"SushiHorizontalPager","text":"<p>SushiHorizontalPager allow users to swipe between pages of content. It provides a way to create carousels, image galleries, onboarding flows, or any UI that requires paging through content, and enables horizontal swiping.</p>"},{"location":"sushihorizontalpager/#example","title":"Example","text":""},{"location":"sushihorizontalpager/#sushihorizontalpager_1","title":"SushiHorizontalPager","text":"<pre><code>// First, create a PagerState that manages the paging behavior\nval pagerState = rememberPagerState(pageCount = { 5 }) // 5 pages\n\n// Create the pager with default settings\nSushiHorizontalPager(\n    state = pagerState,\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(200.dp)\n) { page -&gt;\n    // Content for each page\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        SushiText(\n            props = SushiTextProps(\n                text = \"Page ${page + 1}\",\n                type = SushiTextType.Bold700\n            )\n        )\n    }\n}\n\n// Create a pager with custom styling and behavior\nSushiHorizontalPager(\n    state = pagerState,\n    contentPadding = PaddingValues(horizontal = 32.dp), // Padding on sides\n    pageSpacing = 16.dp, // Space between pages\n    pageSize = PageSize.Fixed(180.dp), // Fixed page width\n    beyondViewportPageCount = 2, // Keep 2 offscreen pages loaded\n    userScrollEnabled = true // Allow user scrolling\n) { page -&gt;\n    // Page content goes here\n}\n</code></pre>"},{"location":"sushihorizontalpager/#programmatic-navigation","title":"Programmatic Navigation","text":"<pre><code>val scope = rememberCoroutineScope()\nval pagerState = rememberPagerState(pageCount = { 5 })\n\n// Navigate to a specific page with animation\nSushiButton(\n    props = SushiButtonProps(text = \"Next Page\"),\n    onClick = {\n        scope.launch {\n            val nextPage = (pagerState.currentPage + 1) % pagerState.pageCount\n            pagerState.animateScrollToPage(nextPage)\n        }\n    }\n)\n</code></pre>"},{"location":"sushihorizontalpager/#auto-scrolling-carousel","title":"Auto-Scrolling Carousel","text":"<pre><code>// Auto-scroll effect\nvar autoScrollEnabled by remember { mutableStateOf(true) }\nval pagerState = rememberPagerState(pageCount = { items.size })\n\nLaunchedEffect(autoScrollEnabled) {\n    if (autoScrollEnabled) {\n        while(true) {\n            delay(3000) // Scroll every 3 seconds\n            val nextPage = (pagerState.currentPage + 1) % pagerState.pageCount\n            pagerState.animateScrollToPage(nextPage)\n        }\n    }\n}\n\n// The pager\nSushiHorizontalPager(\n    state = pagerState,\n    // other properties\n) { page -&gt;\n    // Page content\n}\n</code></pre>"},{"location":"sushihorizontalpager/#using-with-page-indicators","title":"Using with Page Indicators","text":"<pre><code>Box(modifier = Modifier.fillMaxWidth()) {\n    // The pager\n    SushiHorizontalPager(\n        state = pagerState,\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(200.dp)\n    ) { page -&gt;\n        // Page content\n    }\n\n    // Page indicators at the bottom\n    Box(\n        modifier = Modifier\n            .align(Alignment.BottomCenter)\n            .padding(16.dp)\n    ) {\n        SushiIndicator(\n            dotCount = pagerState.pageCount,\n            type = SushiIndicatorType.Balloon(\n                dotsGraphic = DotGraphic(\n                    color = Color.White,\n                    size = 8.dp\n                )\n            ),\n            pagerState = pagerState\n        )\n    }\n}\n</code></pre>"},{"location":"sushihorizontalpager/#component-api","title":"Component API","text":""},{"location":"sushihorizontalpager/#sushihorizontalpager-parameters","title":"SushiHorizontalPager Parameters","text":"<p>Both components share most parameters, with slight differences due to orientation:</p> Parameter Description <code>state</code> The state object to control and observe the pager's state <code>modifier</code> The modifier to be applied to the pager <code>contentPadding</code> Padding to be applied to the pager content <code>pageSize</code> Strategy defining how pages should be sized <code>beyondViewportPageCount</code> The number of pages to keep loaded beyond the visible viewport <code>pageSpacing</code> Spacing between each page <code>flingBehavior</code> The fling behavior that defines how the pager should handle fling gestures <code>userScrollEnabled</code> Whether user scrolling is enabled <code>reverseLayout</code> Whether the layout should be reversed <code>key</code> Optional lambda to provide a unique key for each page <code>pageNestedScrollConnection</code> Nested scroll connection to be applied to each page <code>snapPosition</code> Position to which the pages should snap <code>verticalAlignment</code> Vertical alignment of each page within the pager"},{"location":"sushiicon/","title":"SushiIcon","text":"<p>A composable component that displays an icon from the Sushi design system.</p> <p>SushiIcon renders icons from the Wasabi icon font based on the provided properties. It supports customization of size, color, and click interactions.</p>"},{"location":"sushiicon/#example","title":"Example","text":"<p>The <code>SushiIcon</code> component is used to display an icon from the Sushi design system.</p> <pre><code>SushiIcon(\n    SushiIconProps(\n        code = SushiIconCodes.IconMStarfilled,\n        size = SushiIconSize.Size900\n    )\n)\n</code></pre>"},{"location":"sushiicon/#component-api","title":"Component API","text":""},{"location":"sushiicon/#sushiicon_1","title":"SushiIcon","text":"Parameter Description <code>code</code> The SushiIconCode representing the specific icon to display <code>size</code> The size specification for the icon <code>color</code> The color specification for the icon <code>parsedIcon</code> The parsed Unicode character derived from the icon code"},{"location":"sushiimage/","title":"SushiImage","text":"<p>A composable component that displays images in the Sushi design system.</p> <p>SushiImage provides a consistent way to display images with various customization options like shapes, sizing, scaling, filters, and more. It supports both fixed dimensions and aspect ratio-based sizing, as well as click interactions.</p> <p>The component intelligently handles different combinations of width, height, and aspect ratio:</p> <ul> <li>If width and height are provided, both are applied</li> <li>If width and aspect ratio are provided, height is calculated automatically</li> <li>If height and aspect ratio are provided, width is calculated automatically</li> </ul>"},{"location":"sushiimage/#example","title":"Example","text":"<p>The <code>SushiImage</code> component is used to display images with various customization options.</p> <pre><code>// Basic image from resource\nSushiImage(\n    props = SushiImageProps(\n        painter = painterResource(id = R.drawable.food_image),\n        width = 200.dp,\n        height = 150.dp,\n        contentDescription = \"Food image\",\n        shape = RoundedCornerShape(8.dp),\n        contentScale = ContentScale.Crop\n    ),\n    modifier = Modifier.padding(8.dp)\n)\n\n// Network image with aspect ratio\nval foodImagePainter = rememberAsyncImagePainter(\n    model = \"https://example.com/food.jpg\"\n)\n\nSushiImage(\n    props = SushiImageProps(\n        painter = foodImagePainter,\n        aspectRatio = 16f/9f,\n        contentScale = ContentScale.Crop,\n        shape = RoundedCornerShape(12.dp),\n        contentDescription = \"Food image with aspect ratio\"\n    ),\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"sushiimage/#component-api","title":"Component API","text":""},{"location":"sushiimage/#sushiimage_1","title":"SushiImage","text":"Parameter Description <code>painter</code> The painter responsible for drawing the image content <code>bgColor</code> The background color behind the image <code>aspectRatio</code> The width to height ratio to maintain (e.g., 16/9 = 1.78) <code>height</code> The explicit height for the image (optional) <code>width</code> The explicit width for the image (optional) <code>shape</code> The shape to clip the image to (e.g., RoundedCornerShape) <code>contentDescription</code> Accessibility description of the image for screen readers <code>contentScale</code> How the image should be scaled within its bounds (e.g., Fit, Crop) <code>alpha</code> Opacity level from 0.0 (transparent) to 1.0 (opaque) <code>scaleFactor</code> Additional scaling factor applied to the image size <code>alignment</code> How the image should be aligned within its bounds <code>colorFilter</code> Optional filter to apply color transformations to the image"},{"location":"sushiindicator/","title":"SushiIndicator","text":"<p>A composable that displays page indicators for carousel or pager components.</p> <p>SushiIndicator integrates with Compose's PagerState to automatically reflect the current page and animate transitions between pages. It offers three distinct visual styles:</p> <ul> <li>Balloon: Dots expand like a balloon when active</li> <li>Shift: Active dots expand horizontally into a pill shape</li> <li>Spring: A separate selector dot moves between fixed position dots</li> </ul>"},{"location":"sushiindicator/#example","title":"Example","text":"<p>The <code>SushiIndicator</code> component is used to display page indicators that integrate with pagers.</p> <pre><code>// Create a pager state\nval pagerState = rememberPagerState { 5 }\n\n// Basic Balloon Indicator\nSushiIndicator(\n    dotCount = 5,\n    type = SushiIndicatorType.Balloon(),\n    pagerState = pagerState,\n    modifier = Modifier.padding(16.dp)\n)\n\n// Shift Indicator with custom color\nSushiIndicator(\n    dotCount = 5,\n    type = SushiIndicatorType.Shift(\n        dotsGraphic = DotGraphic(\n            color = SushiTheme.colors.blue.v500.value\n        )\n    ),\n    pagerState = pagerState,\n    modifier = Modifier.padding(16.dp)\n)\n\n// Spring Indicator with custom dots\nSushiIndicator(\n    dotCount = 5,\n    type = SushiIndicatorType.Spring(\n        dotsGraphic = DotGraphic(\n            color = Color.Transparent,\n            borderColor = SushiTheme.colors.base.theme.v500.value,\n            borderWidth = 2.dp,\n            size = 12.dp\n        ),\n        selectorDotGraphic = DotGraphic(\n            color = SushiTheme.colors.base.theme.v500.value,\n            size = 10.dp\n        )\n    ),\n    pagerState = pagerState,\n    modifier = Modifier.padding(16.dp)\n)\n\n// Manual control version\nSushiIndicator(\n    dotCount = totalPages,\n    type = SushiIndicatorType.Balloon(),\n    currentPage = currentPage,\n    currentPageOffsetFraction = { currentOffset },\n    onDotClicked = { index -&gt; \n        // Handle dot click to navigate to that page\n    },\n    modifier = Modifier.padding(16.dp)\n)\n</code></pre>"},{"location":"sushiindicator/#component-api","title":"Component API","text":""},{"location":"sushiindicator/#sushiindicator_1","title":"SushiIndicator","text":"Parameter Description <code>dotCount</code> The total number of pages to display indicators for <code>type</code> The visual style of the indicators (Balloon, Shift, or Spring) <code>pagerState</code> The state of the associated pager component <code>currentPage</code> The current page index (for manual control version) <code>currentPageOffsetFraction</code> Function providing fractional offset (for manual control) <code>dotSpacing</code> Spacing between adjacent dots <code>onDotClicked</code> Optional callback for when a dot is clicked"},{"location":"sushiindicator/#indicator-types","title":"Indicator Types","text":""},{"location":"sushiindicator/#balloon","title":"Balloon","text":"Parameter Description <code>dotsGraphic</code> The appearance configuration for the dots <code>balloonSizeFactor</code> The maximum size multiplication factor for the active dot"},{"location":"sushiindicator/#shift","title":"Shift","text":"Parameter Description <code>dotsGraphic</code> The appearance configuration for the dots <code>shiftSizeFactor</code> The maximum width multiplication factor for the active dot"},{"location":"sushiindicator/#spring","title":"Spring","text":"Parameter Description <code>dotsGraphic</code> The appearance configuration for the background dots <code>selectorDotGraphic</code> The appearance configuration for the moving selector dot"},{"location":"sushiindicator/#dotgraphic","title":"DotGraphic","text":"Parameter Description <code>size</code> The diameter/size of the dot <code>color</code> The fill color of the dot <code>shape</code> The shape of the dot (default is CircleShape) <code>borderWidth</code> Optional width of the border around the dot <code>borderColor</code> The color of the border (if borderWidth is specified)"},{"location":"sushiloader/","title":"SushiLoader","text":"<p>A composable that displays an animated loading indicator with two concentric rotating arcs.</p> <p>SushiLoader provides a visually appealing loading animation using two concentric arcs that rotate at different angles. The component adapts to the available space while maintaining a minimum size to ensure visibility. The animation, colors, and angular relationship between arcs can be customized through props.</p> <p>The loader automatically scales to fill its container while maintaining proper proportions, making it suitable for various use cases from small inline loaders to large centered spinners.</p>"},{"location":"sushiloader/#example","title":"Example","text":"<p>The <code>SushiLoader</code> component is used to display loading indicators with various customizations.</p> <pre><code>// Default loader\nSushiLoader(\n    props = SushiLoaderProps()\n)\n\n// Custom size\nSushiLoader(\n    props = SushiLoaderProps(),\n    modifier = Modifier.size(48.dp)\n)\n\n// Custom colors\nSushiLoader(\n    props = SushiLoaderProps(\n        outerColor = SushiColorData(ColorName.Blue, ColorVariation.Variation500),\n        innerColor = SushiColorData(ColorName.Green, ColorVariation.Variation500)\n    )\n)\n\n// Custom animation speed and angle\nSushiLoader(\n    props = SushiLoaderProps(\n        animationSpeedMultiplier = 2.0f,\n        innerAngleOffset = 90f\n    )\n)\n</code></pre>"},{"location":"sushiloader/#component-api","title":"Component API","text":""},{"location":"sushiloader/#sushiloader_1","title":"SushiLoader","text":"Parameter Description <code>innerAngleOffset</code> The angular offset between the inner and outer arcs in degrees <code>outerColor</code> The color of the outer arc <code>innerColor</code> The color of the inner arc <code>animationSpeedMultiplier</code> Factor that controls animation speed (higher values = faster)"},{"location":"sushimedia/","title":"SushiMedia","text":"<p>A unified media component for the Sushi design system that can display different types of media.</p> <p>SushiMedia provides a single interface for displaying various types of visual content, currently supporting static images and animations. It automatically renders the appropriate component based on the type of media specified in the properties.</p> <p>This abstraction allows for easier transitions between different media types and provides a consistent API for displaying visual content.</p>"},{"location":"sushimedia/#example","title":"Example","text":"<p>The <code>SushiMedia</code> component is used to display different types of media content:</p> <pre><code>// Display an image\nval imageProps = SushiImageProps(\n    painter = painterResource(R.drawable.my_image),\n    contentDescription = \"My Image\",\n    width = 200.dp,\n    height = 150.dp,\n    contentScale = ContentScale.Crop\n)\n\nSushiMedia(\n    props = SushiMediaProps.Image(imageProps),\n    modifier = Modifier.padding(16.dp)\n)\n\n// Display an animation (Lottie)\nval animationProps by rememberSushiAnimationProps(\n    source = LottieAssetSource(\"animation.json\"),\n    playback = SushiAnimationPlayback.AutoPlay(\n        isPlaying = true,\n        restartOnPlay = true,\n        iterations = 3\n    )\n)\n\nSushiMedia(\n    props = SushiMediaProps.Animation(animationProps),\n    modifier = Modifier.size(200.dp)\n)\n</code></pre>"},{"location":"sushimedia/#toggling-between-media-types","title":"Toggling Between Media Types","text":"<pre><code>// State to track current media type\nvar mediaProps by remember { \n    mutableStateOf&lt;SushiMediaProps&gt;(\n        SushiMediaProps.Image(imageProps)\n    ) \n}\n\n// Button to toggle between image and animation\nSushiButton(\n    props = SushiButtonProps(text = \"Toggle Media Type\"),\n    onClick = {\n        mediaProps = if (mediaProps is SushiMediaProps.Image) {\n            SushiMediaProps.Animation(animationProps)\n        } else {\n            SushiMediaProps.Image(imageProps)\n        }\n    }\n)\n\n// Display the current media\nSushiMedia(\n    props = mediaProps,\n    modifier = Modifier.size(200.dp)\n)\n</code></pre>"},{"location":"sushimedia/#component-api","title":"Component API","text":""},{"location":"sushimedia/#sushimediaprops","title":"SushiMediaProps","text":"<p>SushiMediaProps is a sealed class with two implementations:</p> Type Description <code>Image</code> Configuration for displaying a static image <code>Animation</code> Configuration for displaying an animation"},{"location":"sushimedia/#image-properties","title":"Image Properties","text":"<p>When using <code>SushiMediaProps.Image</code>, you provide a <code>SushiImageProps</code> object with the following key properties:</p> Parameter Description <code>painter</code> The painter that will draw the image <code>contentDescription</code> Accessibility description of the image <code>width</code> The desired width of the image <code>height</code> The desired height of the image <code>aspectRatio</code> The aspect ratio to maintain <code>shape</code> The shape to clip the image to <code>contentScale</code> How the image should be scaled <code>alpha</code> The opacity of the image <code>colorFilter</code> Optional color filter to apply to the image"},{"location":"sushimedia/#animation-properties","title":"Animation Properties","text":"<p>When using <code>SushiMediaProps.Animation</code>, you provide a <code>SushiAnimationProps</code> object with the following key properties:</p> Parameter Description <code>source</code> The animation source (asset, file, URL, etc.) <code>playback</code> Controls how the animation plays <code>width</code> The desired width of the animation <code>height</code> The desired height of the animation <code>aspectRatio</code> The aspect ratio to maintain"},{"location":"sushiotpinput/","title":"SushiOTPTextField","text":"<p>A customizable OTP (One-Time Password) input field component for the Sushi design system.</p> <p>SushiOTPTextField provides a series of individual input fields for entering verification codes, with automatic focus management and styling consistent with the Sushi design system. It comes in three visual styles: filled, outlined, and underlined.</p>"},{"location":"sushiotpinput/#example","title":"Example","text":"<p>The <code>SushiOTPTextField</code> component is used to create OTP input fields for verification codes:</p> <pre><code>// Create an OTP state for 6 digits\nval otpState = rememberOtpState(6)\n\n// Use the filled style (default)\nSushiOTPTextField(\n    state = otpState,\n    autoFocus = true, // Automatically focus the first field\n    onComplete = { code -&gt;\n        // Handle the completed 6-digit code\n        println(\"OTP completed: $code\")\n    }\n)\n\n// Or use the outlined style\nSushiOutlinedOTPTextField(\n    state = otpState,\n    autoFocus = true,\n    onComplete = { code -&gt;\n        // Handle the completed 6-digit code\n    }\n)\n\n// Or use the underlined style\nSushiUnderlinedOTPTextField(\n    state = otpState,\n    autoFocus = true,\n    onComplete = { code -&gt;\n        // Handle the completed 6-digit code\n    }\n)\n</code></pre>"},{"location":"sushiotpinput/#customization-examples","title":"Customization Examples","text":"<pre><code>// Custom length (4 digits)\nval otpState4 = rememberOtpState(4)\nSushiOTPTextField(\n    state = otpState4,\n    autoFocus = false,\n    onComplete = { code -&gt; /* Handle 4-digit code */ }\n)\n\n// Custom text style\nSushiOTPTextField(\n    state = otpState,\n    textStyle = TextStyle(\n        fontSize = 24.sp,\n        fontWeight = FontWeight.Bold,\n        textAlign = TextAlign.Center,\n        color = SushiTheme.colors.blue.v700.value\n    ),\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Password masking\nSushiOTPTextField(\n    state = otpState,\n    visualTransformation = PasswordVisualTransformation(),\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Custom colors\nval customColors = SushiOTPTextFieldDefaults.filledColors().copy(\n    focusedContainerColor = SushiTheme.colors.blue.v100,\n    unfocusedContainerColor = SushiTheme.colors.blue.v050,\n    focusedTextColor = SushiTheme.colors.blue.v900,\n    unfocusedTextColor = SushiTheme.colors.blue.v700,\n    cursorColor = SushiTheme.colors.blue.v600\n)\n\nSushiOTPTextField(\n    state = otpState,\n    colors = customColors,\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Error state\nSushiOTPTextField(\n    state = otpState,\n    isError = true,\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Disabled state\nSushiOTPTextField(\n    state = otpState,\n    enabled = false,\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Read-only state (for displaying a pre-filled code)\nSushiOTPTextField(\n    state = otpState,\n    readOnly = true,\n    onComplete = { code -&gt; /* Handle code */ }\n)\n\n// Alphanumeric keyboard (accepts letters and numbers)\nSushiOTPTextField(\n    state = otpState,\n    keyboardType = KeyboardType.Text,\n    onComplete = { code -&gt; /* Handle code */ }\n)\n</code></pre>"},{"location":"sushiotpinput/#programmatically-setting-values","title":"Programmatically Setting Values","text":"<pre><code>// Pre-fill values\notpState.onDigitEntered(0, '1')\notpState.onDigitEntered(1, '2')\notpState.onDigitEntered(2, '3')\notpState.onDigitEntered(3, '4')\n\n// Clear values\nfor (i in 0 until otpState.length) {\n    otpState.onDigitDeleted(i)\n}\n\n// Check if complete\nval isComplete = otpState.isComplete()\n</code></pre>"},{"location":"sushiotpinput/#component-api","title":"Component API","text":""},{"location":"sushiotpinput/#sushiotptextfield-parameters","title":"SushiOTPTextField Parameters","text":"Parameter Description <code>state</code> State controlling the OTP value and behavior <code>enabled</code> Whether the input fields are enabled <code>readOnly</code> Whether the input fields are read-only <code>isError</code> Whether to display the component in an error state <code>autoFocus</code> Whether to automatically focus the first input field when displayed <code>textStyle</code> The style to apply to the input text <code>colors</code> Colors configuration for different states of the component <code>visualTransformation</code> Transformation to apply to the input text (e.g., for masking) <code>keyboardType</code> The type of keyboard to show for input <code>onComplete</code> Callback invoked when all fields are filled"},{"location":"sushiotpinput/#sushiotpstate-methods","title":"SushiOTPState Methods","text":"Method Description <code>onDigitEntered(index: Int, value: Char)</code> Programmatically sets a digit at the specified position <code>onDigitDeleted(index: Int)</code> Clears the digit at the specified position <code>isFieldEmpty(index: Int)</code> Checks if the field at the specified position is empty <code>isComplete()</code> Checks if all fields have been filled <code>code</code> Property that returns the current OTP value (padded with spaces)"},{"location":"sushiradiobutton/","title":"SushiRadioButton","text":"<p>A customizable radio button component for the Sushi design system.</p> <p>SushiRadioButton provides a standard radio button implementation with support for:</p> <ul> <li>Primary and secondary text labels</li> <li>Custom positioning (radio button at start or end)</li> <li>Vertical alignment control</li> <li>Custom colors for selected and unselected states</li> <li>Custom content through the infoContent parameter</li> <li>Accessibility through semantic properties</li> </ul> <p>Radio buttons are typically used in groups where only one option can be selected at a time, though this component doesn't enforce that behavior - it's up to the parent component to manage the selected state across a group of radio buttons.</p>"},{"location":"sushiradiobutton/#example","title":"Example","text":"<p>The <code>SushiRadioButton</code> component is used to create radio button groups where only one option can be selected.</p> <pre><code>var selectedOption by remember { mutableIntStateOf(1) }\n\nSushiRadioButton(\n    props = SushiRadioButtonProps(\n        selected = selectedOption == 1,\n        text = SushiTextProps(\n            text = \"Standard Delivery\",\n            type = SushiTextType.Medium500\n        ),\n        subText = SushiTextProps(\n            text = \"Free \u2022 3-5 business days\",\n            type = SushiTextType.Regular300,\n            color = SushiTheme.colors.text.secondary\n        )\n    ),\n    onClick = { selectedOption = 1 },\n    modifier = Modifier.padding(vertical = 4.dp)\n)\n\nSushiRadioButton(\n    props = SushiRadioButtonProps(\n        selected = selectedOption == 2,\n        text = SushiTextProps(\n            text = \"Express Delivery\",\n            type = SushiTextType.Medium500\n        ),\n        subText = SushiTextProps(\n            text = \"$5.99 \u2022 1-2 business days\",\n            type = SushiTextType.Regular300,\n            color = SushiTheme.colors.text.secondary\n        )\n    ),\n    onClick = { selectedOption = 2 },\n    modifier = Modifier.padding(vertical = 4.dp)\n)\n</code></pre>"},{"location":"sushiradiobutton/#component-api","title":"Component API","text":""},{"location":"sushiradiobutton/#sushiradiobutton_1","title":"SushiRadioButton","text":"Parameter Description <code>id</code> Optional identifier for the radio button <code>selected</code> Whether the radio button is selected (true) or unselected (false) <code>text</code> Primary text properties to display alongside the radio button <code>subText</code> Secondary text properties to display below the primary text <code>enabled</code> Whether the radio button is interactive (true) or disabled (false) <code>unselectedColor</code> The color for the radio button when unselected <code>selectedColor</code> The color for the radio button when selected <code>padding</code> The padding around the radio button component <code>verticalAlignment</code> The vertical alignment of the radio button relative to its text <code>direction</code> The position of the radio button relative to its text (Start or End)"},{"location":"sushiratingbar/","title":"SushiRatingBar","text":"<p>A customizable rating bar component for the Sushi design system.</p> <p>SushiRatingBar displays a row of stars that can be partially or fully filled to represent a rating value. Users can interact with the rating bar to select a rating by tapping on the stars. The component provides visual feedback through scaling animations when pressed.</p> <p>Use this component to collect user ratings or display rating information for items like restaurants, products, or services.</p>"},{"location":"sushiratingbar/#example","title":"Example","text":"<p>The <code>SushiRatingBar</code> component is used to display and collect star ratings:</p> <pre><code>// Create state to track rating value\nvar rating by remember { mutableFloatStateOf(3.5f) }\n\n// Basic usage with default settings (5 stars)\nSushiRatingBar(\n    props = SushiRatingBarProps(\n        rating = rating\n    ),\n    onRatingChange = {\n        rating = it\n        // Handle the rating change\n    }\n)\n\n// Custom configuration\nSushiRatingBar(\n    props = SushiRatingBarProps(\n        rating = rating,\n        starCount = 4,                  // Show 4 stars instead of 5\n        betweenSpacing = 12.dp,         // Custom spacing between stars\n        tintColor = SushiTheme.colors.yellow.v600  // Custom star color\n    ),\n    onRatingChange = {\n        rating = it\n    },\n    modifier = Modifier.height(32.dp)   // Custom height\n)\n\n// Read-only rating display (ignore onRatingChange)\nSushiRatingBar(\n    props = SushiRatingBarProps(\n        rating = 4.5f,\n        tintColor = SushiTheme.colors.yellow.v500\n    ),\n    onRatingChange = { /* do nothing for read-only */ }\n)\n\n// Displaying partial stars\nSushiRatingBar(\n    props = SushiRatingBarProps(\n        rating = 3.7f  // Will show 3 full stars and 1 star at 70% filled\n    ),\n    onRatingChange = { rating = it }\n)\n</code></pre>"},{"location":"sushiratingbar/#component-api","title":"Component API","text":""},{"location":"sushiratingbar/#sushiratingbarprops","title":"SushiRatingBarProps","text":"Parameter Description <code>rating</code> The current rating value, representing the number of filled stars. Can be a fractional value for partial star filling. <code>betweenSpacing</code> The spacing between each star in the rating bar <code>starCount</code> The total number of stars to display in the rating bar (default is 5) <code>tintColor</code> Optional color to apply to the stars"},{"location":"sushiratingbar/#default-values","title":"Default Values","text":"Value Default <code>starCount</code> 5 stars <code>betweenSpacing</code> 10.dp <code>startSize</code> 20.dp (default height)"},{"location":"sushishimmer/","title":"SushiShimmer","text":"<p>A composable that displays a shimmer loading effect over placeholder content.</p> <p>SushiShimmer creates a shimmering animation effect typically used to indicate loading states in UI. It provides a scope that allows creating shimmer effects over custom shapes and text elements.</p>"},{"location":"sushishimmer/#example","title":"Example","text":"<p>The <code>SushiShimmer</code> component is used to create loading state indicators with customizable animations:</p> <pre><code>// Basic shimmer with default properties\nSushiShimmer(\n    props = SushiShimmerProps(),\n    modifier = Modifier.fillMaxWidth()\n) {\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp)\n    ) {\n        // Header with circle and text\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            horizontalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            ShimmerItem(\n                Modifier\n                    .size(50.dp)\n                    .clip(CircleShape)\n            )\n            Column {\n                ShimmerItem(\n                    Modifier\n                        .height(16.dp)\n                        .width(150.dp)\n                        .clip(RoundedCornerShape(4.dp))\n                )\n                Spacer(modifier = Modifier.height(8.dp))\n                ShimmerItem(\n                    Modifier\n                        .height(12.dp)\n                        .width(100.dp)\n                        .clip(RoundedCornerShape(4.dp))\n                )\n            }\n        }\n\n        // Content\n        ShimmerItem(\n            Modifier\n                .fillMaxWidth()\n                .height(120.dp)\n                .clip(RoundedCornerShape(8.dp))\n        )\n    }\n}\n\n// Shimmer with custom colors and animation parameters\nSushiShimmer(\n    props = SushiShimmerProps(\n        bgColor = SushiTheme.colors.blue.v100,\n        animationColor = SushiTheme.colors.blue.v300,\n        animationDuration = 800,\n        animationDelay = 0\n    ),\n    modifier = Modifier.fillMaxWidth()\n) {\n    // Your shimmer content here\n}\n\n// Shimmer with text elements\nSushiShimmer(\n    props = SushiShimmerProps(),\n    modifier = Modifier.fillMaxWidth()\n) {\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp)\n    ) {\n        ShimmerText(\n            sushiTextProps = SushiTextProps(\n                text = \"This is a shimmer text headline\",\n                type = SushiTextType.Bold700\n            ),\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        ShimmerText(\n            sushiTextProps = SushiTextProps(\n                text = \"This is a longer paragraph text that demonstrates how the shimmer effect works.\",\n                type = SushiTextType.Regular400\n            ),\n            modifier = Modifier.fillMaxWidth()\n        )\n    }\n}\n</code></pre>"},{"location":"sushishimmer/#component-api","title":"Component API","text":""},{"location":"sushishimmer/#sushishimmerprops","title":"SushiShimmerProps","text":"Parameter Description <code>bgColor</code> The background color of the shimmer effect <code>animationColor</code> The highlight color that moves across the shimmer <code>animationWidth</code> The width of the highlight gradient in dp <code>angleOffset</code> The angle offset of the gradient to create diagonal effects <code>animationDuration</code> The duration of one complete animation cycle in milliseconds <code>animationDelay</code> The delay between animation cycles in milliseconds"},{"location":"sushishimmer/#sushishimmerscope","title":"SushiShimmerScope","text":"<p>Within the SushiShimmer content lambda, you have access to these functions:</p> Function Description <code>ShimmerItem(modifier: Modifier)</code> Creates a generic shimmer item with the specified modifier. This can be used to create placeholder shapes with the shimmer effect. <code>ShimmerText(sushiTextProps: SushiTextProps, modifier: Modifier)</code> Creates a shimmer text with the specified text properties and modifier. This applies the shimmer effect to text content."},{"location":"sushisnackbar/","title":"SushiSnackbar","text":"<p>A composable that displays a snackbar message with an optional action.</p> <p>SushiSnackbar provides brief feedback about operations through a message at the bottom of the screen. It can include an action button and customizable styling. Snackbars are typically used to inform users of a process that an app has performed or will perform, and provide an opportunity to respond or undo that action.</p>"},{"location":"sushisnackbar/#example","title":"Example","text":"<p>The <code>SushiSnackbar</code> component is typically used with a <code>SushiSnackbarHostState</code> to show messages:</p> <pre><code>// First, create and remember a snackbar host state\nval snackbarHostState = remember { SushiSnackbarHostState() }\nval scope = rememberCoroutineScope()\n\n// Then, add the snackbar host to your Scaffold\nScaffold(\n    modifier = Modifier.fillMaxSize(),\n    snackbarHost = {\n        SushiSnackbarHost(\n            hostState = snackbarHostState,\n            modifier = Modifier.padding(16.dp)\n        )\n    }\n) { innerPadding -&gt;\n    // Your screen content\n\n    // Button to trigger the snackbar\n    SushiButton(\n        props = SushiButtonProps(text = \"Show Snackbar\"),\n        onClick = {\n            scope.launch {\n                // Basic snackbar\n                val basicProps = SushiSnackbarProps(\n                    message = SushiTextProps(\n                        text = \"This is a basic snackbar message\",\n                        type = SushiTextType.Regular400\n                    ),\n                    snackbarDuration = SushiSnackbarDuration.Short\n                )\n                snackbarHostState.showSnackbar(basicProps)\n\n                // Snackbar with action\n                val actionProps = SushiSnackbarProps(\n                    message = SushiTextProps(text = \"Item removed from cart\"),\n                    actionText = SushiTextProps(text = \"UNDO\"),\n                    snackbarDuration = SushiSnackbarDuration.Long\n                )\n                snackbarHostState.showSnackbar(actionProps)\n\n                // Custom colored snackbar\n                val customProps = SushiSnackbarProps(\n                    message = SushiTextProps(\n                        text = \"Payment successful!\",\n                        type = SushiTextType.Medium500,\n                        color = SushiTheme.colors.white\n                    ),\n                    containerColor = SushiTheme.colors.surface.success,\n                    contentColor = SushiTheme.colors.white,\n                    snackbarDuration = SushiSnackbarDuration.Short\n                )\n                snackbarHostState.showSnackbar(customProps)\n            }\n        }\n    )\n}\n</code></pre>"},{"location":"sushisnackbar/#component-api","title":"Component API","text":""},{"location":"sushisnackbar/#sushisnackbarprops","title":"SushiSnackbarProps","text":"Parameter Description <code>message</code> The main text message to display in the snackbar <code>containerColor</code> The background color of the snackbar <code>contentColor</code> The color of the text content <code>actionText</code> The text for the optional action button <code>snackbarDuration</code> Controls how long the snackbar remains visible"},{"location":"sushisnackbar/#sushisnackbarduration","title":"SushiSnackbarDuration","text":"Value Description <code>Short</code> Displayed for a brief period (1500ms) <code>Long</code> Displayed for a longer period (3500ms) <code>Indefinite</code> Displayed until explicitly dismissed"},{"location":"sushisnackbar/#sushisnackbarhoststate","title":"SushiSnackbarHostState","text":"<p>The <code>SushiSnackbarHostState</code> class provides methods to control snackbars:</p> Method Description <code>showSnackbar(snackbarProps: SushiSnackbarProps)</code> Shows a snackbar with the given properties <code>cancelSnackbar()</code> Dismisses the currently displayed snackbar"},{"location":"sushiswitch/","title":"SushiSwitch","text":"<p>A customizable toggle switch component for the Sushi design system.</p> <p>SushiSwitch provides a standard switch component with support for:</p> <ul> <li>Primary and secondary text labels</li> <li>Custom positioning (switch at start or end)</li> <li>Vertical alignment control</li> <li>Customizable colors</li> <li>Custom content through the infoContent parameter</li> <li>Accessibility through semantic properties</li> </ul> <p>Switches are typically used to toggle between two states (on/off) for a single option.</p>"},{"location":"sushiswitch/#example","title":"Example","text":"<p>The <code>SushiSwitch</code> component is used to create toggle switches for settings and preferences.</p> <pre><code>var notificationsEnabled by remember { mutableStateOf(true) }\n\nSushiSwitch(\n    props = SushiSwitchProps(\n        isChecked = notificationsEnabled,\n        text = SushiTextProps(\n            text = \"Push Notifications\",\n            type = SushiTextType.Medium500\n        ),\n        subText = SushiTextProps(\n            text = \"Receive alerts about new offers and updates\",\n            type = SushiTextType.Regular300,\n            color = SushiTheme.colors.text.secondary\n        )\n    ),\n    onCheckedChange = { notificationsEnabled = it },\n    modifier = Modifier.padding(vertical = 4.dp)\n)\n</code></pre>"},{"location":"sushiswitch/#component-api","title":"Component API","text":""},{"location":"sushiswitch/#sushiswitch_1","title":"SushiSwitch","text":"Parameter Description <code>id</code> Optional identifier for the switch <code>isChecked</code> Whether the switch is checked (on) or unchecked (off) <code>text</code> Primary text properties to display alongside the switch <code>subText</code> Secondary text properties to display below the primary text <code>isEnabled</code> Whether the switch is interactive (true) or disabled (false) <code>color</code> The color for the switch when checked <code>padding</code> The padding around the switch component <code>verticalAlignment</code> The vertical alignment of the switch relative to its text <code>direction</code> The position of the switch relative to its text (Start or End)"},{"location":"sushitag/","title":"SushiTag","text":"<p>A customizable tag component for the Sushi design system.</p> <p>SushiTag is a small, compact component typically used to display categories, attributes, or status information. It supports various visual styles (rounded, capsule, outlined, dashed), sizes, and optional prefix/suffix icons.</p> <p>Tags can be interactive (clickable) or static, and can contain custom content or use the standard text and icon layout.</p>"},{"location":"sushitag/#example","title":"Example","text":"<p>The <code>SushiTag</code> component is used to create compact, visual indicators for various attributes and categories.</p> <pre><code>// Basic tag\nSushiTag(\n    props = SushiTagProps(\n        text = \"Capsule\",\n        type = SushiTagType.Capsule,\n        size = SushiTagSize.Medium\n    )\n)\n\n// Tag with icon and custom colors\nSushiTag(\n    props = SushiTagProps(\n        text = \"Vegetarian\",\n        type = SushiTagType.RoundedOutline,\n        size = SushiTagSize.Small,\n        prefixIcon = SushiIconProps(\n            code = SushiIconCodes.IconCheck,\n            color = SushiTheme.colors.green.v600\n        ),\n        borderColor = SushiTheme.colors.green.v600,\n        fontColor = SushiTheme.colors.green.v600\n    )\n)\n</code></pre>"},{"location":"sushitag/#component-api","title":"Component API","text":""},{"location":"sushitag/#sushitag_1","title":"SushiTag","text":"Parameter Description <code>text</code> The text content to display in the tag <code>size</code> The size variant of the tag (affects padding and text size) <code>type</code> The visual style of the tag (affects shape and border) <code>color</code> The background color of the tag <code>fontColor</code> The color of the text and icons in the tag <code>borderColor</code> The color of the border (for outline and dashed types) <code>suffixIcon</code> Optional icon to display after the text <code>prefixIcon</code> Optional icon to display before the text <code>iconSpacing</code> Custom spacing between icons and text <code>shape</code> Optional custom shape to override the default shape from the type <code>markdown</code> Whether to interpret the text content as markdown"},{"location":"sushitext/","title":"SushiText","text":"<p>A customizable text component that supports various styling options, decorations, prefix/suffix icons, and expandable text functionality.</p> <p>Features:</p> <ul> <li>Text styling with different typography styles</li> <li>Optional prefix and suffix icons or custom composables</li> <li>Text decorations like underline and strikethrough</li> <li>Support for markdown formatting</li> <li>Expandable text with \"read more\" functionality</li> <li>Text alignment and arrangement customization</li> </ul>"},{"location":"sushitext/#example","title":"Example","text":"<p>The <code>SushiText</code> component is used to display text with various styles and properties.</p> <pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"Hello World!\",\n        prefixIcon = SushiIconProps(code = SushiIconCodes.IconMoon),\n        suffixIcon = SushiIconProps(code = SushiIconCodes.IconContactlessDining, color = SushiColorData(ColorName.Blue, ColorVariation.Variation500)),\n        color = SushiColorData(ColorName.Red, ColorVariation.Variation500),\n        type = SushiTextType.Regular300,\n        horizontalArrangement = Arrangement.SpaceBetween,\n        textDecoration = SushiTextDecoration.Underline()\n    ),\n    Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"sushitext/#component-api","title":"Component API","text":""},{"location":"sushitext/#sushitext_1","title":"SushiText","text":"Parameter Description <code>text</code> The text content to display <code>color</code> The color specification for the text <code>type</code> The typography style to apply to the text <code>maxLines</code> Maximum number of lines to display before truncating <code>prefixIcon</code> Optional icon to display before the text <code>suffixIcon</code> Optional icon to display after the text <code>letterSpacing</code> Spacing between letters in the text <code>markdown</code> Whether to interpret the text as markdown <code>textDecoration</code> Optional decoration to apply to the text (underline or strikethrough) <code>textAlign</code> Text alignment within its container <code>overflow</code> How to handle text that doesn't fit within maxLines <code>overflowText</code> Text to show as part of the \"read more\" functionality <code>overflowTextColor</code> Color for the overflow text <code>softWrap</code> Whether text should wrap to the next line <code>minLines</code> Minimum number of lines to display <code>prefixSpacing</code> Space between the prefix icon and the text <code>suffixSpacing</code> Space between the text and the suffix icon <code>horizontalArrangement</code> How to arrange content horizontally <code>verticalAlignment</code> How to align content vertically <code>textBrush</code> Optional brush for creating gradient or other effects on text"},{"location":"sushitextfield/","title":"SushiTextField","text":"<p>A customizable text input field component for the Sushi design system.</p> <p>SushiTextField provides a standard text field with support for:</p> <ul> <li>Labels and placeholder text</li> <li>Error states and support text</li> <li>Prefix and suffix text/icons</li> <li>Custom styling via colors and shapes</li> <li>Keyboard options and actions</li> <li>Accessibility features</li> </ul> <p>This component wraps the Material3 OutlinedTextField to maintain consistency with the design system while leveraging the functionality of the standard component.</p>"},{"location":"sushitextfield/#example","title":"Example","text":"<p>The <code>SushiTextField</code> component is used to create text input fields with various configurations.</p> <pre><code>var text by remember { mutableStateOf(\"\") }\n\nSushiTextField(\n    props = SushiTextFieldProps(\n        text = text,\n        label = SushiTextProps(text = \"Phone Number\"),\n        prefixText = SushiTextProps(text = \"+91\"),\n        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),\n        supportText = SushiTextProps(text = \"Enter your mobile number\")\n    ),\n    onValueChange = { text = it },\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"sushitextfield/#component-api","title":"Component API","text":""},{"location":"sushitextfield/#sushitextfield_1","title":"SushiTextField","text":"Parameter Description <code>id</code> Optional identifier for the text field <code>text</code> Current text value displayed in the field <code>textStyle</code> Typography style for the input text <code>placeholder</code> Text displayed when the field is empty <code>enabled</code> Whether the text field is interactive (true) or disabled (false) <code>readOnly</code> Whether the text field allows user input (false) or is read-only (true) <code>isError</code> Whether to display the text field in an error state <code>label</code> Optional label text displayed above the text field <code>keyboardOptions</code> Options controlling the behavior of the software keyboard <code>keyboardActions</code> Actions to perform based on keyboard input <code>singleLine</code> Whether the text field should be limited to a single line <code>showResetButton</code> Show a reset button to clear the text field's input <code>maxLines</code> Maximum number of lines to display when not in single line mode <code>minLines</code> Minimum number of lines to display <code>shape</code> The shape of the text field container <code>visualTransformation</code> Optional transformation for displaying the text (e.g., password masking) <code>supportText</code> Optional supporting text displayed below the text field <code>prefixIcon</code> Optional icon displayed at the start of the text field <code>leadingIcon</code> Optional icon displayed at the start of the text field (always visible) <code>suffixIcon</code> Optional icon displayed at the end of the text field <code>trailingIcon</code> Optional icon displayed at the end of the text field (always visible) <code>prefixText</code> Optional text displayed at the start of the text field <code>suffixText</code> Optional text displayed at the end of the text field <code>colors</code> Color scheme for the text field's various states"},{"location":"sushitooltip/","title":"SushiTooltip","text":"<p>A customizable tooltip component for the Sushi design system.</p> <p>SushiTooltip displays contextual information or hints when users hover over or interact with UI elements. The component supports customizable content, including text, images, and custom layouts, with configurable appearance options like color, shape, and pointer position.</p>"},{"location":"sushitooltip/#example","title":"Example","text":"<p>The <code>SushiTooltip</code> component is used within a <code>SushiTooltipBox</code> to create tooltips:</p> <pre><code>// First, create a tooltip state and remember a coroutine scope\nval tooltipState = rememberTooltipState()\nval scope = rememberCoroutineScope()\n\n// Basic text tooltip\nSushiTooltipBox(\n    positionProvider = TooltipDefaults.rememberRichTooltipPositionProvider(),\n    tooltip = {\n        SushiTooltip(\n            props = SushiTooltipProps(\n                text = SushiTextProps(\n                    text = \"This is a basic tooltip with text only\",\n                    color = SushiTheme.colors.text.inverse\n                )\n            )\n        )\n    },\n    state = tooltipState\n) {\n    // Anchor element - the tooltip will be positioned relative to this\n    SushiButton(\n        props = SushiButtonProps(text = \"Hover or Click Me\"),\n        onClick = {\n            scope.launch {\n                tooltipState.show()\n            }\n        }\n    )\n}\n</code></pre>"},{"location":"sushitooltip/#customization-examples","title":"Customization Examples","text":"<pre><code>// Tooltip with prefix and suffix icons\nSushiTooltip(\n    props = SushiTooltipProps(\n        text = SushiTextProps(\n            text = \"Important information\",\n            color = SushiTheme.colors.text.inverse\n        ),\n        prefixImage = SushiImageProps(\n            painterResource(R.drawable.ic_info),\n            width = 20.dp,\n            contentDescription = \"Info\",\n            colorFilter = ColorFilter.tint(SushiTheme.colors.yellow.v500.value)\n        ),\n        suffixImage = SushiImageProps(\n            painterResource(R.drawable.ic_warning),\n            width = 20.dp,\n            contentDescription = \"Warning\"\n        )\n    )\n)\n\n// Custom colored tooltip\nSushiTooltip(\n    props = SushiTooltipProps(\n        text = SushiTextProps(\n            text = \"Warning: This action cannot be undone\",\n            color = Color.White\n        ),\n        containerColor = SushiTheme.colors.red.v600,\n        prefixImage = SushiImageProps(\n            painterResource(R.drawable.ic_warning),\n            width = 20.dp,\n            contentDescription = \"Warning\",\n            colorFilter = ColorFilter.tint(Color.White)\n        )\n    )\n)\n\n// Custom shape tooltip with no caret\nSushiTooltip(\n    props = SushiTooltipProps(\n        text = SushiTextProps(\n            text = \"This tooltip has a custom shape with no caret\",\n            color = SushiTheme.colors.text.inverse\n        ),\n        caretSize = DpSize.Unspecified,  // No caret\n        shape = RoundedCornerShape(16.dp)  // More rounded corners\n    )\n)\n\n// Tooltip with custom content\nSushiTooltip(\n    props = SushiTooltipProps(\n        containerColor = SushiTheme.colors.blue.v700\n    ),\n    content = {\n        Column(modifier = Modifier.padding(16.dp)) {\n            SushiText(\n                props = SushiTextProps(\n                    text = \"Custom Tooltip\",\n                    type = SushiTextType.Bold600,\n                    color = Color.White\n                )\n            )\n\n            // More custom content...\n        }\n    }\n)\n</code></pre>"},{"location":"sushitooltip/#programmatically-showinghiding-tooltips","title":"Programmatically Showing/Hiding Tooltips","text":"<pre><code>// Show the tooltip\nscope.launch {\n    tooltipState.show()\n}\n\n// Hide the tooltip\nscope.launch {\n    tooltipState.dismiss()\n}\n</code></pre>"},{"location":"sushitooltip/#component-api","title":"Component API","text":""},{"location":"sushitooltip/#sushitooltipprops","title":"SushiTooltipProps","text":"Parameter Description <code>text</code> Properties for configuring the tooltip's text content <code>prefixImage</code> Optional image to display before the text <code>suffixImage</code> Optional image to display after the text <code>containerColor</code> Background color of the tooltip (defaults to inverse surface color) <code>caretSize</code> Size of the tooltip's pointer/caret (width and height) <code>shape</code> Shape of the tooltip container (defaults to rounded corners) <code>shadowElevation</code> Shadow depth for the tooltip to create visual hierarchy"},{"location":"sushitooltip/#sushitooltipbox-parameters","title":"SushiTooltipBox Parameters","text":"Parameter Description <code>positionProvider</code> Provider that determines tooltip position relative to anchor <code>tooltip</code> Tooltip content to be displayed when triggered <code>state</code> State object that controls when the tooltip is shown or hidden <code>focusable</code> Whether the tooltip can receive focus <code>enableUserInput</code> Whether user interactions can trigger the tooltip <code>content</code> The anchor content that the tooltip will be attached to"},{"location":"sushiverticalpager/","title":"SushiVerticalPager","text":"<p>SushiVerticalPager allow users to swipe between pages of content. It provides a way to create carousels, image galleries, onboarding flows, or any UI that requires paging through content, and enables vertical swiping.</p>"},{"location":"sushiverticalpager/#example","title":"Example","text":"<pre><code>// Create a PagerState for vertical paging\nval pagerState = rememberPagerState(pageCount = { 5 })\n\n// Create a vertical pager\nSushiVerticalPager(\n    state = pagerState,\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(400.dp)\n) { page -&gt;\n    // Content for each page\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        SushiText(\n            props = SushiTextProps(\n                text = \"Vertical Page ${page + 1}\",\n                type = SushiTextType.Bold700\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"sushiverticalpager/#programmatic-navigation","title":"Programmatic Navigation","text":"<pre><code>val scope = rememberCoroutineScope()\nval pagerState = rememberPagerState(pageCount = { 5 })\n\n// Navigate to a specific page with animation\nSushiButton(\n    props = SushiButtonProps(text = \"Next Page\"),\n    onClick = {\n        scope.launch {\n            val nextPage = (pagerState.currentPage + 1) % pagerState.pageCount\n            pagerState.animateScrollToPage(nextPage)\n        }\n    }\n)\n</code></pre>"},{"location":"sushiverticalpager/#auto-scrolling-carousel","title":"Auto-Scrolling Carousel","text":"<pre><code>// Auto-scroll effect\nvar autoScrollEnabled by remember { mutableStateOf(true) }\nval pagerState = rememberPagerState(pageCount = { items.size })\n\nLaunchedEffect(autoScrollEnabled) {\n    if (autoScrollEnabled) {\n        while(true) {\n            delay(3000) // Scroll every 3 seconds\n            val nextPage = (pagerState.currentPage + 1) % pagerState.pageCount\n            pagerState.animateScrollToPage(nextPage)\n        }\n    }\n}\n\n// The pager\nSushiVerticalPager(\n    state = pagerState,\n    // other properties\n) { page -&gt;\n    // Page content\n}\n</code></pre>"},{"location":"sushiverticalpager/#using-with-page-indicators","title":"Using with Page Indicators","text":"<pre><code>Box(modifier = Modifier.fillMaxWidth()) {\n    // The pager\n    SushiVerticalPager(\n        state = pagerState,\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(200.dp)\n    ) { page -&gt;\n        // Page content\n    }\n\n    // Page indicators at the bottom\n    Box(\n        modifier = Modifier\n            .align(Alignment.BottomCenter)\n            .padding(16.dp)\n    ) {\n        SushiIndicator(\n            dotCount = pagerState.pageCount,\n            type = SushiIndicatorType.Balloon(\n                dotsGraphic = DotGraphic(\n                    color = Color.White,\n                    size = 8.dp\n                )\n            ),\n            pagerState = pagerState\n        )\n    }\n}\n</code></pre>"},{"location":"sushiverticalpager/#component-api","title":"Component API","text":""},{"location":"sushiverticalpager/#sushiverticalpager-parameters","title":"SushiVerticalPager Parameters","text":"<p>Both components share most parameters, with slight differences due to orientation:</p> Parameter Description <code>state</code> The state object to control and observe the pager's state <code>modifier</code> The modifier to be applied to the pager <code>contentPadding</code> Padding to be applied to the pager content <code>pageSize</code> Strategy defining how pages should be sized <code>beyondViewportPageCount</code> The number of pages to keep loaded beyond the visible viewport <code>pageSpacing</code> Spacing between each page <code>flingBehavior</code> The fling behavior that defines how the pager should handle fling gestures <code>userScrollEnabled</code> Whether user scrolling is enabled <code>reverseLayout</code> Whether the layout should be reversed <code>key</code> Optional lambda to provide a unique key for each page <code>pageNestedScrollConnection</code> Nested scroll connection to be applied to each page <code>snapPosition</code> Position to which the pages should snap <code>horizontalAlignment</code> Horizontal alignment of each page within the pager"},{"location":"sushiviewflipper/","title":"SushiViewFlipper","text":"<p>A composable that automatically cycles through multiple content items with animated transitions.</p> <p>SushiViewFlipper provides a way to display a sequence of items in the same space, automatically transitioning between them with customizable animation. This is useful for displaying rotating promotions, suggestions, or other content that should cycle through multiple options.</p>"},{"location":"sushiviewflipper/#example","title":"Example","text":"<p>The <code>SushiViewFlipper</code> component is used to automatically cycle through different content items:</p> <pre><code>// Basic usage with a list of items\nval searchSuggestions = listOf(\n    \"Search for \\\"Pizza\\\"\",\n    \"Search for \\\"Burger\\\"\",\n    \"Search for \\\"Pasta\\\"\",\n    \"Search for \\\"Sushi\\\"\",\n    \"Search for \\\"Salad\\\"\"\n)\n\n// Create a ViewFlipper that cycles through the suggestions\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = searchSuggestions.size  // Number of items to display\n    ),\n    modifier = Modifier.fillMaxWidth()\n) { index -&gt;\n    // Content for each item based on index\n    SushiText(\n        props = SushiTextProps(\n            text = searchSuggestions[index],\n            color = SushiTheme.colors.text.secondary\n        ),\n        modifier = Modifier.padding(16.dp)\n    )\n}\n</code></pre>"},{"location":"sushiviewflipper/#customization-examples","title":"Customization Examples","text":"<pre><code>// Custom flip interval (faster transitions)\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = items.size,\n        flipInterval = 1000L  // 1 second flip interval\n    ),\n    onFlip = { index -&gt;\n        // Called when a flip occurs\n        currentItemIndex = index\n    }\n) { index -&gt;\n    // Item content\n}\n\n// Custom animation direction\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = items.size,\n        animationDirection = SushiViewFlipperProps.FlipAnimationDirection.FlipToBottom\n        // New content slides in from top, current content slides out to bottom\n    )\n) { index -&gt;\n    // Item content\n}\n\n// Play/Pause control\nvar isPlaying by remember { mutableStateOf(true) }\n\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = items.size,\n        isPlaying = isPlaying  // Control whether animation is playing\n    )\n) { index -&gt;\n    // Item content\n}\n\n// Custom animation duration\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = items.size,\n        animationDuration = 1200,  // Slower animation (1.2 seconds)\n        flipInterval = 4000L       // Show each item for 4 seconds\n    )\n) { index -&gt;\n    // Item content\n}\n</code></pre>"},{"location":"sushiviewflipper/#dynamic-content","title":"Dynamic Content","text":"<pre><code>// Create state for a dynamic item list\nvar itemCount by remember { mutableStateOf(3) }\n\n// ViewFlipper with dynamic count\nSushiViewFlipper(\n    props = SushiViewFlipperProps(\n        count = itemCount  // Can be updated to change the number of items\n    )\n) { index -&gt;\n    // Content for the current index\n}\n\n// Button to update the content\nSushiButton(\n    props = SushiButtonProps(text = \"Add Item\"),\n    onClick = {\n        itemCount++\n    }\n)\n</code></pre>"},{"location":"sushiviewflipper/#component-api","title":"Component API","text":""},{"location":"sushiviewflipper/#sushiviewflipperprops","title":"SushiViewFlipperProps","text":"Parameter Description <code>flipInterval</code> Time in milliseconds between content flips (default: 3000ms) <code>animationDuration</code> Duration of the flip animation in milliseconds (default: 600ms) <code>animationDirection</code> Direction for the flip animation (FlipToTop or FlipToBottom) <code>isPlaying</code> Whether the flipper should be actively cycling (default: true) <code>count</code> Number of items to display in the flipper (default: 1)"},{"location":"sushiviewflipper/#flipanimationdirection","title":"FlipAnimationDirection","text":"Value Description <code>FlipToTop</code> New content slides in from bottom, current content slides out to top <code>FlipToBottom</code> New content slides in from top, current content slides out to bottom"},{"location":"foundations/color-scheme/","title":"Sushi Color Scheme","text":"<p>Sushi Compose UI provides a flexible and expressive color system for building visually unified and accessible apps. The color scheme defines a range of roles such as primary, secondary, error, background, surface, and their respective variants.</p>"},{"location":"foundations/color-scheme/#structure-and-philosophy","title":"Structure and Philosophy","text":"<ul> <li>Palette Roles: Sushi groups colors by semantic purpose (primary, surface, error, etc).</li> </ul>"},{"location":"foundations/color-scheme/#customisations","title":"Customisations:","text":"<ul> <li>Color Schemes: Sushi provides light and dark mode mappings for color tokens, which you can customise as needed.</li> <li>Color Modes: Sushi supports various color modes (accessed via <code>sushi*LightColorScheme()</code>) to choose from, based on the primary colors of your app.</li> </ul>"},{"location":"foundations/color-scheme/#using-sushi-colors","title":"Using Sushi Colors","text":"<p>Access theme colors with <code>SushiTheme.colors</code> inside composables:</p> <pre><code>SushiText(\n  SushiTextProps(\n    text = \"Welcome!\",\n    color = SushiTheme.colors.text.primary\n  )\n)\n</code></pre> <p>You can use these in any Compose element, including backgrounds or content:</p> <pre><code>Box(\n    modifier = Modifier.background(SushiTheme.colors.background.primary)\n) {\n   // Content\n}\n</code></pre>"},{"location":"foundations/color-scheme/#creating-a-custom-color-scheme","title":"Creating a Custom Color Scheme","text":"<p>To personalize your app, create a <code>SushiColorScheme</code>:</p> <pre><code>val CustomScheme = sushiLightColorScheme(\n    materialColorScheme = ...,\n    themeColorScheme = ...,\n    baseColorScheme = ...,\n    textColorScheme = ...,\n    iconColorScheme = ...,\n    ...\n)\n</code></pre> <p>Similarly, other options can be customised:</p> <pre><code>SushiTheme(\n  colorScheme = CustomScheme,\n  typography = SushiTheme.typography,\n  dimens = SushiTheme.dimens,\n  fontSizeMultiplier = SushiTheme.fontSizeMultiplier,\n  colorTokenMapper = SushiTheme.colorTokenMapper\n) {\n  // Your app content\n}\n</code></pre>"},{"location":"foundations/color-scheme/#best-practices","title":"Best Practices","text":"<ul> <li>Ensure high contrast for text accessibility</li> <li>Stick to your brand palette throughout</li> <li>Override all required roles for full control</li> </ul>"},{"location":"foundations/theme/","title":"SushiTheme &amp; App Theming","text":"<p>SushiTheme brings together your color scheme, typography, and shapes into a unified design system for your app. Always wrap your app or screen content in <code>SushiTheme</code>.</p>"},{"location":"foundations/theme/#basic-usage","title":"Basic Usage","text":"<pre><code>import com.zomato.sushi.compose.theme.SushiTheme\n\nSushiTheme {\n    MyAppContent()\n}\n</code></pre>"},{"location":"foundations/theme/#customizing-the-theme","title":"Customizing the Theme","text":"<p>Override any of the color scheme, typography, or shapes:</p> <pre><code>SushiTheme(\n    colorScheme = CustomScheme,\n    typography = CustomTypography,\n    shapes = CustomShapes\n) {\n    // App content here\n}\n</code></pre>"},{"location":"foundations/theme/#wrapping-sushitheme-in-your-own-apptheme","title":"Wrapping SushiTheme in Your Own AppTheme","text":"<p>Create a custom theme for global logic or to enforce branding:</p> <pre><code>@Composable\nfun AppTheme(content: @Composable () -&gt; Unit) {\n    SushiTheme(\n        colorScheme = AppColorScheme,\n        typography = AppTypography,\n        shapes = AppShapes\n    ) {\n        content()\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>AppTheme { MyAppContent() }\n</code></pre>"},{"location":"foundations/theme/#accessing-theme-tokens","title":"Accessing Theme Tokens","text":"<p>Inside a composable, access design tokens like so:</p> <pre><code>val primaryBackground = SushiTheme.colors.background.primary\nval headingStyle = SushiTheme.typography.bold900\n</code></pre>"},{"location":"foundations/theme/#material3-compatibility","title":"Material3 Compatibility","text":"<p>SushiTheme ensures all Material3 components use your custom Sushi settings. <code>MaterialTypography</code> ensures Okra fonts are auto-applied.</p>"},{"location":"foundations/typography/","title":"Sushi Typography","text":"<p>Typography in Sushi Compose UI is flexible and highly structured for consistent, beautiful text styling across your app.</p>"},{"location":"foundations/typography/#font-families","title":"Font Families","text":"<ul> <li>OkraFontFamily: The main UI typeface used throughout Sushi.</li> <li>WasabiFontFamily: Special font for icon glyphs (Wasabicons), enables scalable   color-controllable icons as font chars.</li> </ul> <p>Example:</p> <pre><code>TextStyle(fontFamily = OkraFontFamily, fontWeight = FontWeight.Normal)\n</code></pre>"},{"location":"foundations/typography/#sushitypography-system","title":"SushiTypography System","text":"<p>SushiTypography defines styles for every relevant font weight and size combination:</p> <ul> <li>Weights: light, regular, medium, semiBold, bold, extraBold</li> <li>Sizes: 050 to 900 (increments, see code for details)</li> <li>Naming: <code>weightSize</code> (e.g., bold400, regular300)</li> </ul> <p>Access with:</p> <pre><code>val heading = SushiTheme.typography.bold700\nval body = SushiTheme.typography.regular400\n</code></pre>"},{"location":"foundations/typography/#usage-example","title":"Usage Example","text":"<pre><code>Text(\n    text = \"Welcome to Sushi!\",\n    style = SushiTheme.typography.semiBold500\n)\n</code></pre>"},{"location":"foundations/typography/#customizing-typography","title":"Customizing Typography","text":"<p>Create your own <code>SushiTypography</code> instance:</p> <pre><code>val customTypography = SushiTypography(\n    materialTypography = MaterialTypography,\n    bold400 = TextStyle(fontWeight = FontWeight.Bold, fontSize = 24.sp, fontFamily = OkraFontFamily),\n    // ...fill every required style (see Type.kt)\n)\n</code></pre> <p>And inject it into your theme:</p> <pre><code>SushiTheme(typography = customTypography) { YourUI() }\n</code></pre>"},{"location":"foundations/typography/#integration-with-material-typography","title":"Integration with Material Typography","text":"<p>Sushi also exposes a <code>MaterialTypography</code> object that applies the Okra font to all standard Material components for seamless integration.</p>"},{"location":"markdown/customization/","title":"Customizing Markdown Processing","text":"<p>Sushi's markdown engine is flexible and developer-friendly. You can extend it with custom processors or override its styling as needed.</p>"},{"location":"markdown/customization/#extending-the-processor","title":"Extending the Processor","text":"<p>To support custom syntax or behaviors, provide your own processors or transformers:</p> <pre><code>val customMdProcessor = remember(Unit) {\n    MarkdownParser.Builder()\n        .processor(EmojiMarkdownProcessor())\n        .build()\n}\nval customEmojiText = customMdProcessor.parse(\"I love sushi! :sushi:\")\n\nSushiText(\n    props = SushiTextProps(\n        text = customEmojiText\n    )\n)\n</code></pre>"},{"location":"markdown/overview/","title":"Sushi Markdown Overview","text":"<p>Sushi Compose UI includes out-of-the-box support for rendering Markdown content inside Composables.</p>"},{"location":"markdown/overview/#color-and-weight","title":"Color and Weight","text":"<pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"Hi &lt;bold-700|{red-700|Kotlin User}&gt;\",\n        color = SushiTheme.colors.text.success,\n        type = SushiTextType.Regular200\n    )\n)\n</code></pre>"},{"location":"markdown/overview/#italic","title":"Italic","text":"<pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"This is an _italic_ text\",\n        color = SushiTheme.colors.text.success,\n        type = SushiTextType.Regular200\n    )\n)\n</code></pre>"},{"location":"markdown/overview/#cut-through","title":"Cut through","text":"<pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"This is an ~~cutthrough~~ text\",\n        color = SushiTheme.colors.text.success,\n        type = SushiTextType.Regular200\n    )\n)\n</code></pre>"},{"location":"markdown/overview/#clickable-links","title":"Clickable Links","text":"<pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"This is an [Clickable](https://google.com) text\",\n        color = SushiTheme.colors.text.success,\n        type = SushiTextType.Regular200\n    )\n)\n</code></pre>"},{"location":"markdown/overview/#bold","title":"Bold","text":"<pre><code>SushiText(\n    props = SushiTextProps(\n        text = \"This is an **bold** text\",\n        color = SushiTheme.colors.text.success,\n        type = SushiTextType.Regular900,\n        textDecoration = SushiTextDecoration.Underline()\n    )\n)\n</code></pre>"}]}